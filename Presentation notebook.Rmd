---
title: Estimating present population based on Mobile Network Operator data - a simulation
  study
author: "Stefania, Giulia, Tony, Marco"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    df_print: paged
  bookdown::html_document2:
    code_download: true
    theme: lumen
    toc: true
    toc_float:
      collapsed: false
    number_sections: yes
    fig_caption: yes
knit: (function(input_file, encoding) { out_dir <- 'docs'; rmarkdown::render(input_file,
  encoding=encoding, output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
---

```{r, setup}
# change accordingly
knitr::opts_knit$set(root.dir = normalizePath("C:/Users/Marco/")) 
knitr::opts_chunk$set(fig.width = 10)
knitr::opts_knit$set(eval.after = "fig.cap")
```

```{r packages, message=FALSE}
library(tidyverse)
library(sf)
library(raster)
library(Matrix)
library(knitr)
library(kableExtra)
library(ggthemes)
library(cowplot)
set.seed(762)
```

Mobile phones are an essential part of modern life. From going on Twitter to complain about politics to texting with friends about the latest and hottest gossip and live streaming on Facebook about an underground party to sharing immediate information in the front of the battle lines. Mobile phones have revolutionized the way we communicate with each other and how we lead our daily lives. From the point of view in Official Statistics, mobile phones present an opportunity like no other: a fast and immediate calculation of present population. Present population "is composed by all individuals who are physically present in the geographic area of interest at a selected reference time" [1]. In this study, we will evaluate and compare different estimation techniques to infer the present population in a specific region. We will particularly focus on the quality of the estimation when simulating hotspots (high population density) in low signal density areas. This is the case for example on holidays where people go on vacation in less urbanized areas.

This exercise will be a simulation study partly based on real and simulated data from either official sources or from our own calculations. The notebook relies on multiple scripts that follow a methodological/technical chain. Each chain element can be considered as an independent module which makes it easy to change parameters in a module and follow through with the remaining chain. Therefore, multiple objects are created in advance (in an efficient manner because of parallelization) and loaded into the notebook. The objects will be explained, their parameters presented and the source code hyperlinked in this notebook.

Currently three modules are implemented:

-   Generating a population based on real census data and spatial demographic clustering

-   Generating a radio cell network with multiple parameters

-   Creating the device-to-cell association

# Generating a semi-synthetic population based on real census data

We have retrieved population census data from the German Federal Statistical Office on Germany [2] (<https://www.destatis.de/EN/Home/_node.html>). This data entails population count categories on the 100m\*100m tile level. For computational reasons, this version will only focus on a subset of the tiles located in the state of Bavaria, which is situated in the south-east of Germany. We chose this area because it comprises both urban, suburban, and rural areas. The underlying code is written in a modular way in order to have the possibility to re-purpose our models for other regions. Furthermore, once a high computing machine is available, we could easily scale this notebook to the entirety of Germany.

The sample population value is used as the number of mobile phones in a specific tile and throughout in this current version of the notebook. This sample population is a direct reference to the u vector in the working paper. In subsequent versions, this original population value could be adjusted based on additional variables to get a more realistic count of people with mobile phones in each tile.

The link to the source code for the census.de.100.m.tile object is [here](https://github.com/R-ramljak/MNO_GM/blob/master/1_Read%20in%20data.R).

```{r exploration census, message=FALSE}
census.de.100m.tile <- readRDS("Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/census.tile.final.rds") 


dim(census.de.100m.tile)
class(census.de.100m.tile) 
census.de.100m.tile %>% 
  st_drop_geometry() %>%  
  sample_n(10) %>%  
  # head() %>% 
  kbl(caption = "Exploration of the dataset on the tile level (focus area)") %>% 
  kable_minimal() 
```

\#\#Exploration of the dataset about tiles of South Bavaria

Important features and parameters:

-   Our focus areas entails `r dim(census.de.100m.tile)[1]` tiles on a regular grid (South Bavaria)

-   We have a continuous and a `r dim(census.de.100m.tile)[2]` level ordinal variable representing the population density for each tile

In order to imitate the real life situation where only one mobile carrier will provide us with their data, we have first randomly extracted a third of the population vector. Continuing with that, in the following section we then proceed to classify the tiles based on the number of populations per tile as well its proximity to neighboring tiles in order identify groups of tiles into different categories of urbanization. In this section we will be using the `cca` function from the `OSC` package. After the classification, we then proceed to look at the overall distribution of the tiles based on the categories of urbanization.

```{r focus area, fig.width = 7, fig.cap="We will only focus on a subset of the tiles located in the state of Bavaria because it comprises both urban, suburban, and rural areas" }
# Bounding box of focus area
bb.focus.dat <- data.frame(xmin = 4400000, xmax = 4500000,
                           ymin = 2700000, ymax = 2900000)
bb.focus.vec <- c(xmin = 4400000, xmax = 4500000,
                  ymin = 2700000, ymax = 2900000)
# Download data from : https://gadm.org/download_country_v3.html --> R(sf) level 1
germany.raw <- readRDS("Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/gadm36_DEU_1_sf.rds") 
germany <- germany.raw %>%  
  st_transform(crs = 3035)
focus.area.plot <- germany %>%  
  ggplot() + 
  geom_sf() + 
  geom_rect(data = bb.focus.dat, aes(ymin = ymin, ymax = ymax,  
                                      xmin = xmin, xmax = xmax,  
                                     color = "red"),  
            size = 1, fill = "transparent") + 
  ggtitle("") + 
  scale_color_identity(name = "", 
                       labels = c("Focus area"), 
                       guide = "legend") +
  labs(x = NULL, y = NULL,
       title = "")
 
plot_grid(focus.area.plot, 
          labels = "Fig.1: Focusing on a part of South Bavaria",
          hjust = -0.1, label_size = 13)
```

```{r pop distribution 1, fig.cap= "Figure 2a shows the classification results from the clustering algorithm and the proportion of people in the area categories.While Figure 2b shows the distribution of the four different categories of tiles obtained throught spatial clustering."}

# Since there is a large percentage of zeros in the tiles, we added 1 to every tile to receive valid values for the log transformation
# ECCDF of population distribution 
ECCDF.pop.data <- census.de.100m.tile %>% 
  # sample_n(1000) %>%
  mutate(pop.plot = pop + 1) %>%  
  arrange(pop.plot) %>%  
  mutate(prob = 1 / n()) %>%  
  mutate(cum.prob = cumsum(prob)) %>%  
  mutate(log10.cum.prob.comp = log10(1 - cum.prob)) %>%  
  mutate(log10.pop = log10(pop.plot)) %>%  
  mutate(cum.prob.comp = 1 - cum.prob) %>% 
  mutate(pop.area.kind = case_when(pop == 0 ~ "Uninhabitated", 
                                   TRUE ~ pop.area.kind))

prop.class <- data.frame( 
  class = c("Rural","Suburban", "Uninhabitated","Urban"), 
  n = summary(as.factor(ECCDF.pop.data$pop.area.kind)), 
  prop = round(summary(as.factor(ECCDF.pop.data$pop.area.kind)) / length(census.de.100m.tile$internal.id), digits = 4) * 100)  %>% 
  mutate(class = factor(class)) %>% 
  arrange(desc(class)) %>% 
  mutate(lab.ypos = cumsum(prop) - 0.5 * prop) 
 
tile.prop.plot <- prop.class %>% 
  ggplot(aes(x = "", y = prop, fill = class)) + 
  geom_bar(width = 1, stat = "identity", color = "white") + 
  scale_fill_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban")) +
  geom_text(aes(y = lab.ypos, label = paste0(prop, "%")), color = "black") +
  labs(x = "Class", y = "Number of tiles", title = "",
    subtitle = "Fig. 2a: Tile proportion") + 
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5))
 
cluster.plot <- census.de.100m.tile %>%
  filter(pop.area.kind %in% c("Suburban", "Urban")) %>% 
  ggplot() +  
  geom_sf(aes(col = factor(pop.area.kind)), show.legend = F) + 
  ggtitle("", subtitle = "Clustering Results") + 
  theme(plot.margin = unit(c(0, 0, 0, 0), "mm")) +  
  scale_color_manual(breaks = c("Suburban", "Urban"), values = c("#117733", "#CC6677")) +
   labs(subtitle = "Fig. 2b: Clustering results") +
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5))

plot_grid(cluster.plot, tile.prop.plot, labels = "Fig.2 : Population Classification",  
            hjust = -0.1, label_size = 14, rel_widths = c(0.8, 1)) 
```

Figure 2 shows the classification results from the clustering algorithm and the proportion of people in the area categories. We aimed at having 4 different categories: Uninhabited, Rural, Suburban and Urban. When working on this very low spatial resolution, one cannot just classify tiles independently based on their respective continuous population value but ones needs to take spatial dependence into consideration in order to classify urban centers. Therefore, we apply a spatial clustering method, mainly for identifying the last two categories. In order to run the clustering algorithm, the original census population is first divided into tiles above and below 15 people per tile. Tiles below 15 are either classified as Uninhabited or Rural, from the start (uninhabited corresponds to the tiles with 0 population). The clustering is then done on the tiles that are above 15 people per tile. Based on the results of the clustering, we define urban areas as clusters that have an agglomeration of more than 100 tiles. Suburban areas are defined as clusters that have more than 50 and less than or equal to 100 tiles. The remaining clusters are considered as Rural areas and therefore result in the same classification as the tiles from above, which had less than 15 people.

The stacked bar plot shows the proportions of the tiles according to the four categories. Based on our clustering algorithm, `r prop.class$prop[1]`% of the tiles are urban areas. `r prop.class$prop[2]`% of the tiles are uninhabited areas. `r prop.class$prop[3]`% of the tiles are suburban areas, and `r prop.class$prop[4]`% of the tiles are rural areas.

```{r pop distribution 2, fig.cap= "The Figure 3a shows the geographical distribution of the tiles classified thought the clustering algorithm of the population. In Figure 3b there is rapresented  the logarithm of ECCDF of the population data and the graph inside the figure 3b is the linear ECCDF." }

pop.dist.map.plot <- ECCDF.pop.data %>% 
  # sample_n(10000) %>%
  ggplot() + 
  geom_sf(aes(color = pop.area.kind), show.legend = F) + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban")) + 
  ggtitle("", subtitle = " Fig. 3a : Geographic distribution") + 
  theme(plot.margin = unit(c(0, 0, 0, 0), "mm"), axis.text.x=element_text(angle=90, hjust=1)) 
 
ECCDF.pop.plot <- ECCDF.pop.data %>%   
  # sample_n(1000) %>% 
  ggplot() + 
  geom_point(aes(x = log10.pop, y = log10.cum.prob.comp, 
                 color = pop.area.kind)) + 
  geom_hline(yintercept = -0.3010300, linetype = "dotted") + 
  geom_hline(yintercept = -1, linetype = "dotted") + 
  geom_text(x = 1.5, y = -0.2, label = "50% of the data") + 
  geom_text(x = 1.5, y = -0.9, label = "90% of the data") + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban")) + 
  ggtitle("", subtitle = "Fig. 3b: Empirical cumulative complementary\ndistribution function") +  
  labs(y = "log10(Prob(Y > x))", x = "log10(Mobile phones)",  
        colour = "") + 
  ylim(-7, 0) +
  theme(legend.position = "bottom") 
 
ECDF.pop.plot <- ECCDF.pop.data %>%   
  # sample_n(1000) %>% 
  ggplot() + 
  geom_point(aes(x = pop.plot, y = cum.prob.comp, color = pop.area.kind)) + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban"), guide = FALSE, expand = c(0, 0)) +
  xlim(0, 30) +
  labs(y = "", x = "") +
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

pop.dist.ecdf.insert <- ECCDF.pop.plot +
  annotation_custom(ggplotGrob(ECDF.pop.plot), 
                    xmin = 0, xmax = 1.5, 
                    ymin = -7, ymax = -3)

plot_grid(pop.dist.map.plot, pop.dist.ecdf.insert, labels = "Fig. 3: Mobile phone density per tile",  
          hjust = -0.1, label_size = 14, rel_widths = c(0.8, 1))
```

Figure 3 shows the mobile phone density per tile in the focus area. In particular, we have 4 different colors representing the clusters: Uninhabited, Rural, Suburban and Urban.

However, to have a deeper look of the mobile phone density per tile, in the figure (write the figure number of the first ECCDF) we choose to represent data with an empirical cumulative complementary distribution function [using a log base 10 transformation].

The ECCDF is a step function with jumps `i/n` at observation values, where `i` is the number of tied observations at that value. Moreover, missing values are ignored and the objective "complementary" means that we need to subtract 1 - the cumulative probability. It is commonly used with variables that a have highly skewed distribution ??? as expected the population variable on this low spatial resolution at hand is heavily right skewed.

As the figure suggests, 50% of the data are represented by uninhabited tiles with no phones; furthermore, 90% of the tiles contain less than half of the mobile phones in our focus area. One can also see the tiles' classification based on the clustering results. Some tiles classified as Rural have higher values for their mobile phone population - this is because they are not considered as an Urban or Suburban cluster, as mentioned above. 10% left are tiles both urban and rural containing 0.5 and above mobile phones.

# Generation of a synthetic Radio Network

We generate a radio network, which is composed of three layers. The layers follow the pop.area.kind variable - layer 1 (Rural) spans over the rural, suburban and urban tiles, layer 2 (Suburban) spans over the suburban and urban tiles and layer 3 (Urban) is spanned over the urban tiles.

**Important features and parameters of the generated radio network are:**

-   The layers follow a hexagon shape with cell towers located in the respective centroid of each hexagon

-   Towers vary in distance to each other of the same layer, i.e. how far/close are towers of the same layer located to each other: layer 1 = 27,000m; layer 2 = 7000m; layer 3 = 900m (-\> the more urbanized, the closer the towers are too each other -\> denser coverage). Furthermore, hexagon independent rotation in terms of the first layer is executed: layer 2 = 35 degrees; layer 3 = 70 degrees

-   Each cell tower location is jittered in order to break the symmetry. The jitter amount depends on the layer: layer 1 = 5000m, layer 2 = 1000m, layer 3 = 400m.

-   Each tower contains three antennas pointing into 120 degree differing directions.

-   The layer determines the coverage diameter of an antenna: layer 1 = 15,000m; layer 2 = 2500m; layer 3 = 500m

-   Each tile of the focus area is sufficiently covered by at least one antenna and the antennas' coverage areas are allowed to overlap.

-   Parameters concerning the device to cell association are specified in the next section

The link to the source code for the layers.1 object as well as the coverage.areas.1 object is [here](https://github.com/R-ramljak/MNO_GM/blob/master/2_Radio%20cell%20generation.R).

The link to the source code for the layers object as well as the coverage.areas object is [here] (<https://github.com/R-ramljak/MNO_Eurostat/blob/master/code/2_Radio%20cell%20generation.R>).

```{r network layers, fig.width = 7, fig.cap = "The figure presents the hexagonal structure. Each triangle is a tower location with some randomness implemented."}
layers <- readRDS("Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/radio cell layers.rds") 
coverage.areas <- readRDS("Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/coverage.areas.rds") 
 
coverage.layer1 <- coverage.areas %>%  
  filter(area.kind == "Rural") %>%  
  st_drop_geometry() %>%  
  dplyr::select(-antenna.centroid) %>%  
  st_as_sf(coords = c("X.tow", "Y.tow"), crs = 3035) 
 
layers.plot <- layers[[1]] %>% 
  st_as_sf(crs = 3035) %>%  
  ggplot() + 
    # geom_rect(data = bb.focus.dat, aes(ymin = ymin, ymax = ymax,  
    #                                   xmin = xmin, xmax = xmax),  
    #         color = "black", size = 0.3, alpha = 0.5, fill = alpha("grey", 0)) + 
  geom_sf(linetype = "dotted") + 
  geom_sf(data = coverage.layer1, aes(color = "#4273C5"), shape = 17) + 
  scale_color_identity(name = "", 
                       # breaks = c("Focus area"), 
                       labels = c("Jittered tower location"), 
                       guide = "legend") + 
  labs(x = NULL, y = NULL,
       title = "",
    subtitle = "Towers are located in the centroid of a hexagon.") +
  theme(plot.title = element_text(size=10, face="bold", hjust = 0.5),
  plot.subtitle = element_text(size=9,hjust = 0.5))
   
plot_grid(layers.plot,
          labels = "Fig. 4:Radio network - Example Layer 1 (Rural)",
          hjust = -0.1, label_size = 14)
```

We use a hexagonal structure to place towers across our focus area. This is a quite realistic setup for cell towers. Each hexagon corresponds to one tower which is originally placed in the centroid of the respective hexagon. In order to exclude symmetrical structure, we implement some randomness in the exact location of the cell towers. Figure 3 exemplifies the effect of the jitter parameter in the 1st layer - the actual location deviates slightly from the centroid in order to break the symmetry of the underlying hexagonal structure. This is done for every layer.

The setup of a tower with its corresponding antennas is in every layer the same: Three antennas per tower, pointing into 120 degree differing directions. The animated visualization exemplifies this for any generic tower.

```{r animation}
knitr::include_graphics("https://github.com/R-ramljak/MNO_Eurostat/raw/master/antenna%20animation.gif")
```

Basically, a tower is generated at its specified location, then three antennas are created. For the operationalized data structure, the antenna location is not really relevant as it corresponds to the respective tower location. What is more important are the antennas' *coverage area centroids* because they describe the middle point of the then generated circular coverage area. The specific radius of any generic coverage area is layer specific and listed above. As indicated in the animation, an antenna specific coverage area is setup with a variable *coverage intensity profile*. Basically, cell phones that are closer to the coverage area centroid of any antenna, have a higher coverage probability, which will be later introduced as the *signal strength* parameter.

The following table presents the number of towers and the number of antennas of each layer. The number of antennas is not always a perfect factor of 3 as the coverage areas are cropped according to the focus area. This means if the complete coverage area of an antenna lies outside of the focus area it is discarded.

```{r coverage areas 1}
tile.count <- census.de.100m.tile %>%  
  st_drop_geometry() %>% 
  group_by(pop.area.kind) %>%  
  summarise(area.in.sq.km = n() / 100) %>% 
  arrange(desc(pop.area.kind)) %>% 
  mutate(area.in.sq.km = case_when(pop.area.kind == "Rural" ~ cumsum(area.in.sq.km),
                                   pop.area.kind == "Suburban" ~ cumsum(area.in.sq.km),
                                   pop.area.kind == "Urban" ~ cumsum(area.in.sq.km))) %>% 
  arrange(pop.area.kind)

coverage.areas %>%  
  st_drop_geometry() %>%  
  group_by(area.kind, tower.ID) %>%  
  summarise(n.antenna = n(), .groups = "drop") %>%  
  ungroup() %>%  
  group_by(area.kind) %>%  
  summarise(n.tower = n(), 
            n.antenna = sum(n.antenna), .groups = "drop") %>%  
  left_join(tile.count, by = c("area.kind" = "pop.area.kind")) %>%  
  dplyr::select(layer = area.kind, n.tower, n.antenna, area.in.sq.km) %>%  
  kbl(caption = "Descriptive statistics per coverage layer") %>%
  kable_minimal() %>%
  footnote(general = "`area.in.sq.km` reports the actual area that was used for the generation of the coverage. Therefore, the first layer spans over the whole focus area, the second layer over the suburban and urban area, and the third layer over the urban area.")
```

As described in the parameter list above, rural areas are covered only by layer 1, suburban areas are covered by layer 1 and 2 and the urbanized areas are covered by all three layers. The distances between towers of the same layer decrease in layer 2 and layer 3 compared to layer 1. This leads to denser networks within these layers represented by the higher numbers of towers and therefore higher numbers of antennas in layer 2 and 3, given their area. The reason for this is that any generic antenna can only offer signal service to a limited amount of number of mobile phones. To cover all cell phones in more urbanized areas a denser radio cell network is needed in these areas. This feature will be later introduced as the *capacity* parameter.

The following figures present the actual coverage of each layer for the focus area.

```{r coverage areas 2, fig.cap = "The circles represent the coverage area of each antenna per layer. The signal density increases with increasing population density."}
coverage.area.plot <- coverage.areas %>%  
  ggplot() + 
  geom_sf(aes(col = area.kind), fill = NA) + 
  facet_grid(cols = vars(area.kind)) + 
  ggtitle("") + 
    scale_color_ptol(breaks = c("Rural", "Suburban", "Urban"), "Layer") +
  labs(x = NULL, y = NULL) +
  theme(axis.text.x=element_text(angle=90, hjust=1),plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
  plot.subtitle = element_text(size = 9, hjust = 0.5))

plot_grid(coverage.area.plot, labels = "Fig. 5: Coverage per layer",
          hjust = -0.1, label_size = 14) 
```

The interpretations of the table above correspond to the level of coverage of each layer. It should be noticed that the antennas' coverage areas are allowed to overlap - with antennas of the same tower, as well as across towers of the same or another layer.

```{r coverage areas 3, fig.cap = "The figure on the left shows the geographical distribution of the tiles classified into the three layers based on the spatial clustering. On the right side, the coverage per layer is represented. The full coverage corresponds to the population density."}
# Implement shape of focus area
coverage.area.full.plot <- coverage.areas %>% 
  ggplot() +
  geom_sf(aes(col = area.kind), fill = NA) +
  ggtitle("", subtitle = "Full coverage") +
    scale_color_ptol(breaks = c("Rural", "Suburban", "Urban"), "Layer") +
  theme(axis.text.x=element_text(angle=90, hjust=1),
        plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
  plot.subtitle = element_text(size = 9, hjust = 0.5))

plot_grid(pop.dist.map.plot, coverage.area.full.plot, labels = "Fig. 6: Full coverage corresponding to the density", 
          hjust = -0.1, label_size = 14)
```

Figure 6 presents the full network structure. By comparing the network structure to the tile density one can see that full, partially overlapping coverage is granted for all areas and that the network layering structure follows suit with the true geographical population density.

```{r coverage intensity, fig.width = 7, fig.cap= paste0("The distribution is right skewed with a mean of ", round(mean(coverage.intensity$count), 2),", a minimum of ", min(coverage.intensity$count),", and a maximum of ", max(coverage.intensity$count)," antenna(s) per tile.")}
tiles.cat <- readRDS("Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/coverage intensity.rds")
coverage.intensity <- tiles.cat %>%
  arrange(count) %>%
  mutate(prob = 1 / n()) %>%
  mutate(cum.prob = cumsum(prob))

coverage.intensity.plot <- coverage.intensity %>%
  ggplot() +
  stat_count(aes(count), fill = "#4477A9") +
  geom_vline(xintercept = mean(coverage.intensity$count), linetype = "solid", color = "#117733", size = 1.5) +
  geom_vline(xintercept = median(coverage.intensity$count), linetype = "solid", color = "#CC6677", size = 1.5) +
  annotate("text", x = median(coverage.intensity$count) - 2, y = 5e+05, color = "#CC6677",
           label = paste("Median =", median(coverage.intensity$count))) +
  annotate("text", x = round(mean(coverage.intensity$count), 2) + 2, y = 5e+05, color = "#117733", 
           label = paste("Mean =", round(mean(coverage.intensity$count), 2))) +
  labs(y = "Count of tiles", x = "Covered by ... antennas", colour = "", title = "")
  
  
plot_grid(coverage.intensity.plot, labels = "Fig. 7: Number of antennas covering a tile",
          hjust = -0.1, label_size = 14)
```

Figure 7 shows a histogram representing the number of antennas per tile. The distribution is right skewed with a mean of `r round(mean(coverage.intensity$count), 2)`, a minimum of `r min(coverage.intensity$count)` and a maximum of `r max(coverage.intensity$count)` antenna(s) per tile. Even though the coverage areas were generated synthetically, this distribution mimics a realistic layout.

# Device-to-cell association

At this stage we have added to the geographically distributed mobile phone population a radio network, which is setup in three layers, spanning respectively across tiles that correspond to specific tile classification. (`pop.area.kind`).

The following module will establish the association between mobile phones of a generic tile to a relevant antenna. The result will be a reference matrix $P$ of size $I x J$, where I denotes the total number of radio cells (antennas), $J$ is the total number of tiles and the elements correspond to the probability of the mobile phones of any tile $j$ are registered in the cell $i$. With $P$ one is able to simulate the column vector $c$ (random variable) which describes the total count of mobile phone associated to a radio cell.

Assuming that $\mathcal{L}_{j}$ denotes the subset of radio cells covering a particular tile (remember, overlapping coverage areas are very common). This means that these respective radio cells are competing with each other to be associated with the cell phones in the tile. We therefore assign probabilities which describe the respective association between a radio cell $i$ and tile $j$. This probability depends on the parameter signal strength which we mimic with a simple linear function that describes the gradual decrease in signal the further away the tile centroid $j$ is from the coverage area centroid of $i$:

$$
s_{ij} = \frac{d_{ij}}{r_{i}}
$$

We basically calculate the distance between the two centroids, $d_{ij}$, and divide it between the radius of that radio cell, $r_{i}$- it is denoted by $s_{ij}$. We introduce a minimum threshold value $\nu$ which limits radio cells with a too low signal intensity $s_{ij}$ for a particular tile to be able to be picked up by a mobile phone in that tile - resulting in the minimum value of 0. We also introduce a maximum threshold, describing tiles that are very close to the coverage area centroid, i.e. a high value for $s_{ij}$ -- when passing this threshold their respective $s_{ij}$ values result in the maximum value 1. This particular operationalization of a function modeling the signal strength parameter instead of fixed categorical signal strength values makes the overall workflow of the notebook more realistic (granularity) and more modular as one can later implement very easy even more realistic functions describing the signal strength parameter. In this scenario we have implemented a minimum threshold of $\nu = 0.01$ and a maximum threshold of $\zeta = 0.01$ depending on $r_{i}$. The exact operationalization can be found [here](https://github.com/R-ramljak/MNO_GM/blob/master/3_device%20to%20cell.R).

The elements of $P$ - the probability with which the mobile phones within a particular cell are associated with a particular radio cell - are defined by

$$
p_{ij} = \frac{s_{ij}}{\sum_{i \in \mathcal{L}_{j}} s_{ij}}
$$

where $s_{ij}$ describes the signal intensity of a particular cell $i$ associated with a particular tile $j$, and $\mathcal{L}_{j}$ describes the subset of radio cells that are covering the tile $j$. We then simulate the tile specific experiments - every mobile phone within a tile will be independently assigned to relevant radio cell with the probability $p_{ij}$. The result is the column vector $c$ which will act as a reference for the later on introduced estimation strategies.

```{r c.vector.distribution, fig.cap= "Mobile devices are predominately associated with Layer 1 antennas."}
C.vec.df <- readRDS("Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/C.vec.df.final.new.rds")
# ECCDF of population distribution 
ECCDF.phones.data <- C.vec.df %>% 
  mutate(layer = case_when(str_detect(antenna.ID, "RT") ~ "Layer 1",
                           str_detect(antenna.ID, "ST") ~ "Layer 2",
                           str_detect(antenna.ID, "UT") ~ "Layer 3")) %>% 
  arrange(phones.sum) %>%  
  mutate(prob = 1 / n()) %>%  
  mutate(cum.prob = cumsum(prob)) %>% 
  mutate(cum.prob.comp = 1 - cum.prob) %>% 
  mutate(log10.cum.prob.comp = log10(1 - cum.prob)) %>%  
  mutate(log10.phones = log10(phones.sum))

ECCDF.phones.plot <- ECCDF.phones.data %>%   
  ggplot() + 
  geom_point(aes(x = log10.phones, y = log10.cum.prob.comp, 
                 color = layer)) + 
  geom_hline(yintercept = -0.3010300, linetype = "dotted") + 
  geom_hline(yintercept = -1, linetype = "dotted") + 
  geom_text(x = 4, y = -0.15, label = "50% of the data") + 
  geom_text(x = 4, y = -0.85, label = "90% of the data") + 
  scale_color_ptol(breaks = c("Layer 1", "Layer 2", "Layer 3")) + 
  ggtitle("") +
  labs(y = "log10(Prob(Y > x))", x = "log10(Mobile phones)", colour = "")+
  theme(plot.title = element_text(size=10, face="bold", hjust = 0.5),
        plot.subtitle = element_text(size=9,hjust = 0.5))
ECDF.phones.plot <- ECCDF.phones.data %>%   
  ggplot() + 
  geom_point(aes(x = phones.sum, y = cum.prob.comp, color = layer)) + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban"), guide = FALSE, expand = c(0, 0)) +
  labs(y = "", x = "") +
  xlim(0, 10000) +
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())
pop.dist.ecdf.insert <- ECCDF.phones.plot +
  annotation_custom(ggplotGrob(ECDF.phones.plot), 
                    xmin = 0, xmax = 2, 
                    ymin = -3.5, ymax = -1)
    
plot_grid(pop.dist.ecdf.insert, labels = "Fig. 8: ECCDF Device-to-cell association",  hjust = -0.1, label_size = 14)
```

```{r c.vector special cases, fig.width = 7, fig.cap = "These antennas have more than 10,000 mobile devices associated to themselves. They all belong to layer 1 and are located close or within urban centers."}

extreme.antennas.plot <- C.vec.df %>%  
  filter(phones.sum >= 10000) %>% 
  left_join(coverage.areas, by = "antenna.ID") %>% 
  st_as_sf() %>% 
  ggplot() + 
  geom_sf(aes(col = area.kind), fill = NA) + 
  ggtitle("") + 
  scale_color_ptol(breaks = c("Rural", "Suburban", "Urban"), "Layer") +
  labs(x = NULL, y = NULL) +
  theme(axis.text.x=element_text(angle=90, hjust=1),plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
  plot.subtitle = element_text(size = 9, hjust = 0.5))

plot_grid(extreme.antennas.plot, labels = "Fig. 9: Extreme antennas",
          hjust = -0.1, label_size = 14) 
```

# Estimation strategies

Currently three specific estimation strategies are implemented:

-   Voronoi tesselation (tower locations as seeds)

-   Bayes rule: $\hat{u}_{j} = a_{j}\sum_{i = 1}^{I} c_{i} \frac{p_{ij}}{\sum_{k = 1}^{J} p_{ik} a_{k}}$

-   MLE Poisson: $\hat{u}^{m+1}_{j} = \hat{u}^{m}_{j}\sum_{i = 1}^{I} c_{i} \frac{p_{ij}}{\sum_{k = 1}^{J} p_{ik} \hat{u}^{m}_{k}}$

## Voronoi tesselation

```{r, Voronoi prep}
# adding to the coverage areas the results of the c vector
coverage.areas.comp <- coverage.areas %>% 
  left_join(c.vec, by = "antenna.ID") %>% 
  mutate(phones.sum = case_when(is.na(phones.sum) ~ 0,
                                TRUE ~ phones.sum))

## derive the shape of the focus area
# census.geo.body <- census.de.100m.tile %>% 
#   select(internal.id) %>% 
#   summarise(geometry = st_union(geometry))
# saveRDS(census.geo.body, "Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/shape.focusarea.rds")
census.geo.body <- readRDS("Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/shape.focusarea.rds")


# select only the internal id and the mobile phone population per tile
census.de.100m.tile.pop <- census.de.100m.tile %>% 
  select(internal.id, pop)

```

Voronoi tesselation uses seeds to calculate Voronoi regions. For every seed there is one Voronoi region that contains the area that is closest to the particular seed. There are two seed specifications we are interested in:

-   Tower locations as seeds --\> `n =` `r length(unique(coverage.areas$tower.ID))`

-   Coverage area centroid (per antenna) locations as seeds --\> `n =` `r length(unique(coverage.areas$antenna.ID))`

Below we specify the tower locations as seed points. These are then used to compute the Voronoi regions. Before we do that we need to make sure that the corresponding c.vector is aggregated on the toer level. We then join the Voronoi regions with the tiles to create an object that links tiles within respective Voronoi regions.

```{r voronoi tower prep}
# aggregating the antennas to towers (and corresponding values) and identifying problematic tower locations (outside of focus area)
tower.aggr <- coverage.areas.comp %>% 
  st_drop_geometry() %>% 
  group_by(tower.ID) %>% 
  mutate(phones.sum = sum(phones.sum)) %>% 
  distinct(tower.ID, .keep_all = T) %>% 
  ungroup() %>% 
  select(tower.ID, X.tow, Y.tow, phones.sum) %>%
  st_as_sf(coords = c("X.tow", "Y.tow")) %>% 
  st_sf(crs = 3035) %>%  
  mutate(within.fa = lengths(st_within(., census.geo.body))) # find seeds outside the focus area

# saving towerIDs of problematic towers
towers.outside.ID <- tower.aggr %>% 
  filter(within.fa == 0) %>% 
  select(tower.ID) %>% 
  deframe()

# filtering unproblematic towers
towers.inside <- tower.aggr %>% 
  filter(within.fa == 1)

# Finding respective nearest point on focus area border for every problematic tower location and binding the unproblematic towers back
# this object contains the final seed locations in the geometry
towers.final.data <- tower.aggr %>% 
  filter(within.fa == 0) %>%
  st_nearest_points(., census.geo.body) %>% 
  st_cast("POINT") %>% 
  .[seq(2, length(.), 2)] %>% # 
  st_as_sf() %>% 
  mutate(tower.ID = towers.outside.ID) %>% 
  mutate(geometry = x) %>% 
  st_sf(sf_column_name = "geometry") %>% 
  select(-x) %>% 
  bind_rows(towers.inside)

sum(unlist(st_intersects(towers.final.data, census.geo.body))) == length(tower.aggr$tower.ID) # check if all are within now

# Using the seed object to calculate the Voronoi regions
tower.seed.voronoi <- towers.final.data %>%  
  st_geometry() %>% 
  st_union() %>% 
  st_voronoi() %>% 
  st_collection_extract(type = "POLYGON") %>% 
  st_sf(crs = 3035) %>% 
  st_join(tower.aggr) %>%  # rejoin with seed object to retain seed id
  st_intersection(census.geo.body)
```

And now the same preparation for the coverage area centroids (here also just "antennas" even though this is imprecise).

```{r voronoi antenna and tower prep plot, fig.cap="The tower centroids were used as seeds for the creation of the Voronoi regions."}
### antennas
# aggregating the antennas to towers (and corresponding values) and identifying problematic tower locations (outside of focus area)
antenna.aggr <- coverage.areas.comp %>% 
  st_drop_geometry() %>% 
  select(antenna.ID, geometry = antenna.centroid, phones.sum) %>%
  st_sf() %>% 
  st_sf(crs = 3035) %>%  
  mutate(within.fa = lengths(st_within(., census.geo.body))) # find seeds outside the focus area

# saving towerIDs of problematic antennas
antennas.outside.ID <- antenna.aggr %>% 
  filter(within.fa == 0) %>% 
  select(antenna.ID) %>% 
  deframe()

# filtering unproblematic antennas
antennas.inside <- antenna.aggr %>% 
  filter(within.fa == 1)

# Finding respective nearest point on focus area border for every problematic antenna location and binding the unproblematic towers back
# this object contains the final seed locations in the geometry
antennas.final.data <- antenna.aggr %>% 
  filter(within.fa == 0) %>%
  st_nearest_points(., census.geo.body) %>% 
  st_cast("POINT") %>% 
  .[seq(2, length(.), 2)] %>% # 
  st_as_sf() %>% 
  mutate(antenna.ID = antennas.outside.ID) %>% 
  mutate(geometry = x) %>% 
  st_sf(sf_column_name = "geometry") %>% 
  select(-x) %>% 
  bind_rows(antennas.inside)

# sum(unlist(st_intersects(antennas.final.data, census.geo.body))) == length(antenna.aggr$antenna.ID) # check if all are within now

# Using the seed object to calculate the Voronoi regions
antenna.seed.voronoi <- antennas.final.data %>%  
  st_geometry() %>% 
  st_union() %>% 
  st_voronoi() %>% 
  st_collection_extract(type = "POLYGON") %>% 
  st_sf(crs = 3035) %>% 
  st_join(antenna.aggr) %>%  # rejoin with seed object to retain seed id
  st_intersection(census.geo.body)

# Visualizing the Vornoi regions with respective phone count
VT.plot.1 <- tower.seed.voronoi %>% 
  ggplot() +
  geom_sf(aes(fill = phones.sum, col = phones.sum)) + # add 4 level factor scale
  ggtitle("", subtitle = "Tower locations as seeds")

VA.plot1 <- antenna.seed.voronoi %>% 
  ggplot() +
  geom_sf(aes(fill = phones.sum, col = phones.sum)) + # add 4 level factor scale
  ggtitle("", subtitle = "Coverage area centroid locations as seeds")

plot_grid(VT.plot.1, VA.plot1, labels = "Fig. 10: Voronoi tower estimation",  hjust = -0.1, label_size = 14)
```


We have now created the Voronoi regions for our focus area with tower locations as seeds as well as with antenna respective coverage area centroid locations as seeds. The number of seeds and Voronoi regions align with each other.

The spatial density per tile can be expressed as the ratio of the mobile phones in that region and the area of the Voronoi region:

$d_{k} = \frac{\sum c_{i}} {A_{k}}$

This region specific estimate corresponds to the tile estimate for a tile that is contained in this region. On the tile level there can be two cases that we need to differentiate:

-   Tiles that are completely contained within one Voronoi region 

-   Tiles that intersect with two or more Vornoi regions

For the first case, the tile specific estimate corresponds to $d_{k}$. For the second case we will calculate a weighted mean of the relevant Voronoi region estimates by using the corresponding tile area within each Voronoi region as weights. 

```{r Voronoi tower multiples, fig.cap="This is an example of a tile that intersects with multiple Voronoi regions. The labels and number correspond to the Voronoi region and the given area that are used as weights for the weighted mean estimator."}
# spatial densities per Voronoi region
tower.voronoi.est <- tower.seed.voronoi %>% 
  mutate(area = as.numeric(st_area(.$geometry))) %>% 
  mutate(voronoi.est = phones.sum / area) # the sum of the product of this and the area is the total pop


# Joining the regions with the tile specific data
tower.seed.voronoi.join <- tower.voronoi.est %>% 
  st_join(census.de.100m.tile.pop) %>% # & re-connect the data items
  st_set_agr("aggregate") %>% # clean up
  group_by(internal.id) %>% 
  mutate(count = n()) %>% 
  ungroup()

# identifiying tiles intersecting with multiple Voronoi regions
tower.multiple <- tower.seed.voronoi.join %>%
  st_drop_geometry() %>% 
  filter(count > 1) %>% 
  distinct(internal.id) %>% 
  deframe()

# calculate area within competing voronoi regions of "multiple" tiles
tower.intersect.tiles <- census.de.100m.tile.pop %>% 
  filter(internal.id %in% tower.multiple) %>%
  st_intersection(tower.voronoi.est) %>% 
  st_collection_extract(type = "POLYGON") %>% # select the polygons
  mutate(amount.tiles = as.numeric(st_area(.$geometry)) / 10000) # checked if it adds up to 1


example.helper <- tower.intersect.tiles %>%
  filter(internal.id == "342403") %>% 
  select(tower.ID) %>% 
  deframe()

# example plot
VT.bird.example.plot <- tower.intersect.tiles %>%
  filter(internal.id == "342403") %>%
  ggplot() +
  geom_sf(color = "black") +
  geom_sf(data = (census.de.100m.tile %>% filter(internal.id == "342403")), color = "red", fill = NA) +
  geom_sf(data = (tower.seed.voronoi %>% filter(tower.ID %in% example.helper)), fill = NA) +
  ggtitle("", subtitle = "Birds view of a tile that intersects with 
multiple regions")

VT.example.plot <- tower.intersect.tiles %>% 
  filter(internal.id == "342403") %>% 
  ggplot() +
  geom_sf() + # add description and scales
  geom_sf_label(aes(label = tower.ID)) +
  geom_sf_text(aes(label = paste0("(", round(amount.tiles, 2), ")")), nudge_y = -7) +
  geom_sf(data = (census.de.100m.tile.pop %>% 
  filter(internal.id == "342403")), color = "red", fill = NA) +
  ggtitle("", subtitle = "Area within each Voronoi region")

plot_grid(VT.bird.example.plot, VT.example.plot, 
          labels = "Fig. 11: Example multiple tile",  hjust = -0.1, label_size = 14)
```

And now the same again for the antennas.
```{r Voronoi antenna multiples, fig.cap="This is an example of a tile that intersects with multiple Voronoi regions. The labels and number correspond to the Voronoi region and the given area that are used as weights for the weighted mean estimator."}
# spatial densities per Voronoi region
antenna.voronoi.est <- antenna.seed.voronoi %>% 
  mutate(area = as.numeric(st_area(.$geometry))) %>% 
  mutate(voronoi.est = phones.sum / area) # the sum of the product of this and the area is the total pop


# Joining the regions with the tile specific data
antenna.seed.voronoi.join <- antenna.voronoi.est %>% 
  st_join(census.de.100m.tile.pop) %>% # & re-connect the data items
  st_set_agr("aggregate") %>% # clean up
  group_by(internal.id) %>% 
  mutate(count = n()) %>% 
  ungroup()

# identifiying tiles intersecting with multiple Voronoi regions
antenna.multiple <- antenna.seed.voronoi.join %>%
  st_drop_geometry() %>% 
  filter(count > 1) %>% 
  distinct(internal.id) %>% 
  deframe()

# calculate area within competing voronoi regions of "multiple" tiles
antenna.intersect.tiles <- census.de.100m.tile.pop %>% 
  filter(internal.id %in% antenna.multiple) %>%
  st_intersection(antenna.voronoi.est) %>% 
  st_collection_extract(type = "POLYGON") %>% # select the polygons
  mutate(amount.tiles = as.numeric(st_area(.$geometry)) / 10000) # checked if it adds up to 1

```
We can now calculate the estimated spatial density per tile.

```{r VT and VA estimate}
#### Towers

# final datatset to calculate spatial density
tower.voronoi.final <- tower.intersect.tiles %>% 
  st_drop_geometry() %>% 
  select(internal.id, tower.ID, amount.tiles) %>% 
  right_join(tower.seed.voronoi.join, by = c("internal.id", "tower.ID")) %>% 
  mutate(amount.tiles = case_when(is.na(amount.tiles) ~ 1,
                                  TRUE ~ amount.tiles)) %>% 
  group_by(internal.id) %>% 
  mutate(voronoi.est.corrected = weighted.mean(x = voronoi.est, w = amount.tiles) * 10000) %>% 
  distinct(internal.id, voronoi.est.corrected, pop) # should result in same length as the raw tiles object and the sum of the vornoir est corrected should resemble the sum of the c.vec


#### antennas

# final datatset to calculate spatial density
antenna.voronoi.final <- antenna.intersect.tiles %>% 
  st_drop_geometry() %>% 
  select(internal.id, antenna.ID, amount.tiles) %>% 
  right_join(antenna.seed.voronoi.join, by = c("internal.id", "antenna.ID")) %>% 
  mutate(amount.tiles = case_when(is.na(amount.tiles) ~ 1,
                                  TRUE ~ amount.tiles)) %>% 
  group_by(internal.id) %>% 
  mutate(voronoi.est.corrected = weighted.mean(x = voronoi.est, w = amount.tiles) * 10000) %>% 
  distinct(internal.id, voronoi.est.corrected, pop) # should result in same length as the raw tiles object and the sum of the vornoir est corrected should resemble the sum of the c.vec


```


## Simple Bayes

## MLE Poisson

```{r estimations 1.1}
equal.100.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/Estimation%20Plots/equal.100.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "Evolution")
equal.resid.100.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/Estimation%20Plots/equal.resid.100.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "Residual")

plot_grid(equal.100.plot, equal.resid.100.plot, 
          labels = "",  hjust = -0.1, label_size = 12,
          ncol = 2, nrow = 1)
```
```{r estimations 1.2}
ematrix = readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/Estimation%20Plots/100.equal.rmspe.rds", method = "libcurl"))

ematrix %>% 
  kbl(caption = "Equal prob P.matrix, constant prior: RMSE") %>% 
  kable_minimal() 
```

```{r estimations 2.1}
true.100.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/Estimation%20Plots/true.100.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "Evolution")
true.resid.100.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/Estimation%20Plots/true.resid.100.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "Residual")

plot_grid(true.100.plot, true.resid.100.plot, 
          labels = "",  hjust = -0.1, label_size = 12,
          ncol = 2, nrow = 1)
```

```{r estimations 2.2}
tmatrix = readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/Estimation%20Plots/100.true.rmspe.rds", method = "libcurl"))

ematrix %>% 
  kbl(caption = "Equal prob P.matrix, constant prior: RMSE") %>% 
  kable_minimal() 
```

# Evaluation of the MLE Poisson estimator

This section is still under construction. We will evaluate the estimators and their convergence behaviour from three perspectives:

1.  Distributional evaluation based on a stratified sample: We will visualize the convergence behaviour/the evolution of the estimands up to 1000 iterations. This is executed based on a stratified sample (strata: three level `pop.area.kind` variable), n = 150)

2.  Geographical evaluation: !Still under construction! We will visualize the potential resemblance between the true values and the estimands' values for selected iterations. This is executed for the complete number of tiles in the focus area.

3.  Statistical evaluation: !Still under construction! We will compute global metrics for the estimators performance such as the average absolute discrepancy between the estimands and the true values.

## Convergence Evaluation

```{r distributionl eval 1, fig.cap= "The left and right plots show a stratified sample (strata: area kind) and the tile specific estimatands' convergence behaviour. The convergence behaviour differs between area kinds. The right plot emphasizes that the true value is not necessarily reached."}

equal.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/Estimation%20Plots/equal.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "Evolution")
equal.resid.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/Estimation%20Plots/equal.resid.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "Residual")

plot_grid(equal.plot, equal.resid.plot,
          labels = "Convergence behaviour (Equal P.matrix)", 
          label_size = 12, hjust = -0.1) 

```

The graphs above shows how the estimated population evolve over time (left) as well as its prediction error (right). From the graph on the left, most of the estimated population stabilizes rather quickly in rural and suburban tiles. With the urban tiles, it is harder to say exactly when the convergence will occur, especially there are a bit of variation. The residual plot (right) shows the error of prediction in comparison to the actual population in that specific tile. The rural tiles shows a trend of constant error of prediction over iterations. The suburban tiles generally shows the same trend as well, but also shows that there are tiles that overestimated. The urban tiles tend to have an underestimation.

```{r distributionl eval 2, fig.cap= "The left and right plots show a stratified sample (strata: area kind) and the tile specific estimatands' convergence behaviour (equal probability P.matrix). The convergence behaviour differs between area kinds. The right plot emphasizes that the true value is not necessarily reached."}

true.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/Estimation%20Plots/true.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "Evolution")

true.resid.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/Estimation%20Plots/true.resid.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "Residual")

plot_grid(true.plot, true.resid.plot,
          labels = "Convergence behaviour (True P.matrix)", 
          label_size = 12, align = "hv", hjust = -0.1) 

```

Using the true population matrix, the estimated population stabilizes faster over time in comparison to the equal population matrix. However, there are a few tiles that do not stabilize as fast as we hoped. This is particularly evident in the urban tiles. The residual plot (right) shows the error of prediction over time by the type of tile. There seems to be a trend of increasing prediction error as the degree of urbanization increases as well. We can see that the range of error for suburban tiles range from 30 to -10 and the range of error for urban tiles are between 100 and -75. The suburban tiles seems to underestimate and the urban tiles seems to overestimate.

## Geographical Evaluation

*!!! The plots with a 4 level scale and more iterations will be added until friday. They need to be rendered before for faster load in.*

```{r geo eval 1}
# comparison
iter.title <- c("1 iteration", "2 iterations", "10 iterations", "20 iterations", "50 iterations", "100 iterations",
                "1 iteration", "2 iterations", "10 iterations", "20 iterations", "50 iterations", "100 iterations")

est.plot.list <- list.files("Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/estimation plots/", 
                            pattern = "*.rds", full.names = TRUE) %>% 
  map(readRDS) %>% 
  map2(., iter.title, ~.x + labs(title = "", subtitle = .y) + theme_void())
  
plot_grid(est.plot.list[[1]], est.plot.list[[2]],
          est.plot.list[[3]], est.plot.list[[4]], 
          est.plot.list[[5]], est.plot.list[[6]], 
          labels = "Equal prob P.matrix, constant prior", label_size = 12,
          align = "hv", hjust = -0.1)

```

```{r geo eval 2}
plot_grid(est.plot.list[[7]], est.plot.list[[8]],
          est.plot.list[[9]], est.plot.list[[10]], 
          est.plot.list[[11]], est.plot.list[[12]], 
          labels = "True prob P.matrix, constant prior", label_size = 12,
          align = "hv", hjust = -0.1)
```

## Statistical/Distributional Evaluation

-   Average Absolute Discrepancy: $D_{avg}(u,v) = \frac{1}{U}\sum_{j = 1}^{J} |u_{j} - v_{j}|$

-   Maximum Absolute Discrepancy: $D_{max}(\textbf{u,v}) \overset{\underset{\mathrm{def}}{}}{=} \sum_{\mathit{j = 1}}^{\mathit{J}}\left | u_{j} - v_{j} \right |$

```{r voronoi vs MLE}

aad.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/AADMAD/aad.comp.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "AAD")

mad.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/AADMAD/mad.comp.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "MAD")

plot_grid(aad.plot, mad.plot,
          labels = "Voronoi Estimation vs MLE", 
          label_size = 12, align = "hv", hjust = -0.1) 
```
By calculating the two discrepancy measures, we can then evaluate the overall performance for each type of estimation. It is important to note that the MLE estimates are calculated from the 1000th iteration. In general, the Voronoi estimations results in less discrepancy compared to MLE estimations. Between the two MLE estimations, the true population matrix has a lower discrepancy than the equal population matrix. Between the two Voronoi estimations, the Voronoi estimation by antennas has a lower discrepancy than the Voronoi estimation by towers.

```{r}

aad.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/AADMAD/equal.aad.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "AAD")

mad.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/AADMAD/equal.mad.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "MAD")

plot_grid(aad.plot, mad.plot,
          labels = "Discrepancy Over Time, Equal Pop. Matrix", 
          label_size = 12, align = "hv", hjust = -0.1)
```
For the equal population matrix, the discrepancy values stabilizes as the number of iterations increases. More specifically, starting at the 700th iteration, the discrepancy values are largely the same. 

```{r}
aad.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/AADMAD/true.aad.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "AAD")

mad.plot <- readRDS(url("https://github.com/R-ramljak/MNO_Eurostat/raw/master/Plots/AADMAD/true.mad.plot.rds", method = "libcurl")) + ggtitle("", subtitle = "MAD")

plot_grid(aad.plot, mad.plot,
          labels = "Discrepancy Over Time, True Pop. Matrix", 
          label_size = 12, align = "hv", hjust = -0.1)
```
For the true population matrix, the discrepancy values stabilizes as the number of iterations increases. More specifically, starting at the 300th iteration, the discrepancy values are largely the same. 

# References

[1] Ricciato F, Lanzieri G., Wirthmann A., and Seynaeve G.(2020) Towards a methodological framework for estimating present population density from mobile network operator data. <https://ec.europa.eu/eurostat/cros/content/towards-methodological-framework-estimating-present-population-density-mobile-network-operator-data-extended-version_en>

[2]<https://gadm.org/download_country_v3.html>

[3]<https://www.destatis.de/EN/Home/_node.html>

[4]<https://tma.ifip.org/2016/phdSchool/data/toy_excercise_solution.pdf>
